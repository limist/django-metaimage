Overview
========

django-metaimage is a GPL-licensed app for the Django web framework.
Many sites deal with images/photos, which usually come from three
sources: uploaded by a user, pulled from the Internet via a URL, or
generated server-side.  For the latter two cases, django-metaimage
should be helpful: a new instance can take either a remote image URL,
or raw image data as a string (e.g. as might be produced via
Matplotlib).

The main MetaImage model provides a wrapper of useful functionality
around ImageModel from the powerful django-photologue app (a
dependency).  Some of the django-metaimage code was initially inspired
from Pinax's photo app, but I have removed Pinax dependencies, so that
django-metaimage only requires:

1. Django 
2. django-photologue
3. django-autoslug
4. django-taggit
5. django-uni-form, trunk (optional)

You might need django-uni-form, if you want to use the included
example templates, and want to see all django-metaimage's tests pass.

In sum, this app is provides more flexibility with local
representation of images on your site from multiple sources, whether
uploaded, from remote images, or sever-side generated images.


Usage
-----

The main class, MetaImage, enables storing useful metadata about
images, including a title, caption, notes about the source
(e.g. copyrights, permissions), and tags.  MetaImage attributes
include:

- title, slug, caption, source_note (for attribution text, copyrights, etc.)
- source_url (if any)
- privacy 
- safetylevel
- tags


Now, to handle the two cases of storing images that the app was made
for: retrieval of a remote image from its URL (you'll have a local
copy in case the image moves/disappears), or storing a server-side
generated image:

- With a remote image, simply specify the source_url field in the new
  MetaImage instance and save it, e.g.

::

    new_metaimage = MetaImage(
        title='Django logo',
        source_url='http://media.djangoproject.com/img/site/hdr_logo.gif',
        source_note='The logo of the Django project.',
        creator=foo_user)
    new_metaimage.save()  # Will download, save source_url locally.


- With a server-side generated image - as a string object - one would
  send in the keyword argument image_data when saving, e.g.

::

    new_metaimage = MetaImage(
        title='Chart of f(x)',
        source_note='Chart of f(x) generated by Matplotlib.',
        creator=foo_user)
    new_metaimage.save(image_data=a_png_as_str)


Useful MetaImage methods include:

- render() and render_linked(), which spits out the HTML to show your
  image on a webpage, with a hyperlink to a details-page.


Basic views, tests, and templates are also provided, so you can
quickly integrate the app into an existing Django site.


Installation
------------

Install via "pip install django-metaimage" or from source. You may
also need to do pip install for django-taggit, django-autoslug, and
photologue.  

Then update your Django project's settings.py file: add "photologue",
"taggit" and "metaimage" (autoslug does not need to be there) in the
INSTALLED_APPS list, e.g.

::

    INSTALLED_APPS = [
        ...
        "photologue",
        "taggit",
        "metaimage",
        ...
        ]


And then, do a "manage.py syncdb" to create the database tables
needed.


OPTIONAL: Templates are provided for adding, editing, viewing, etc. of
metaimages; they're very basic and meant only as a starting point.
But if you want to use them directly, do at least these two things:

1. Get and install django-uni-form > 0.7.0 which some of the templates
   rely on, and also update your setting.py INSTALLED_APPS to list
   "uni_form" as a package dependency.
2. Update your site-wide urls.py, e.g.


::

    urlpatterns = patterns("",
        ...
        (r"^metaimage/", include("metaimage.urls")),
        ...
        )


Also, many of the django-metaimage templates have templatetags
dependencies that are commented out, as they require Pinax or other
packages; you can activate them as needed, but be sure to update your
INSTALLED_APPS accordingly.


Testing
-------

I've included a set of unit tests for the app; if you have integrated
django-metaimage into an existing Django site/project, just do the
usual "manage.py test" and the tests should be run, BUT for all tests
to pass, the current trunk (as of 2/2011) of django-uni-form is
needed:

https://github.com/pydanny/django-uni-form


Should you want to run django-metaimage's test suite outside of any
particular Django site/project - i.e. stand-alone Django app testing -
I suggest installing and using the django-app-test-runner and my fork
of it at:

https://github.com/limist/django-app-test-runner

...which enables usage of a testing-specific settings file.  After you
install django-app-test-runner in your virtualenv (don't develop in
Python without it!) you should be able to do something like:

::

    cd to/where/django-metaimage/code/is
    app-test-runner ./src/metaimage/ -s src/metaimage/testsettings.py


Note that you'll need Internet connectivity for the tests to pass.


Errors, etc.
------------

Please log errors/issues using django-metaimage's github site,
http://github.com/limist/django-metaimage/issues

